package dmos

// THIS FILE WAS GENERATED BY generate_go.js

import (
	"gopkg.in/mgo.v2/bson"
	"strconv"
)

type Expr interface {
	F(data interface{}) interface{}
}

type Expr_literal struct {
	Any interface{}
}

func (pred Expr_literal) F(data interface{}) interface{} {

	return pred.Any

}

type Expr_true struct {
}

func (pred Expr_true) F(data interface{}) interface{} {

	return true

}

type Expr_false struct {
}

func (pred Expr_false) F(data interface{}) interface{} {

	return false

}

type Expr_get struct {
	Keys []string
}

func (pred Expr_get) F(data interface{}) interface{} {

	var value interface{}
	value = data
	for _, key := range pred.Keys {
		switch t := value.(type) {
		case map[string]interface{}:
			value = t[key]
		case bson.M:
			value = t[key]
		case []interface{}:
			i, _ := strconv.Atoi(key)
			value = t[i]
		}
	}

	return value

}

type Expr_seq struct {
	Delegates []Expr
}

func (pred Expr_seq) F(data interface{}) interface{} {

	var value interface{}
	value = data
	for _, p := range pred.Delegates {
		value = p.F(value)
	}
	return value

}

type Expr_eq struct {
	Values []Expr
}

func (pred Expr_eq) F(data interface{}) interface{} {

	v := pred.Values[0].F(data)
	for i := 1; i < len(pred.Values); i++ {
		v2 := pred.Values[i].F(data)

		if (v == nil || v2 == nil) && (v != nil || v2 != nil) {
			return false
		}

		if tV, ok := v.(int); ok {
			v = int64(tV)
		}
		if tV2, ok := v2.(int); ok {
			v = int64(tV2)
		}
		if _, ok := v.(float64); ok {
			if tV2, ok2 := v2.(int64); ok2 {
				v2 = float64(tV2)
			}
		}
		if _, ok := v2.(float64); ok {
			if tV, ok2 := v.(int64); ok2 {
				v = float64(tV)
			}
		}

		if v != v2 {
			return false
		}
		v = v2
	}
	return true

}

type Expr_and struct {
	Predicates []Expr
}

func (pred Expr_and) F(data interface{}) interface{} {

	for _, p := range pred.Predicates {
		if !p.F(data).(bool) {
			return false
		}
	}
	return true

}

type Expr_or struct {
	Predicates []Expr
}

func (pred Expr_or) F(data interface{}) interface{} {

	for _, p := range pred.Predicates {
		if p.F(data).(bool) {
			return true
		}
	}
	return false

}

func QToExpr(query []interface{}) Expr {
	fname := query[0].(string)

	switch fname {
	case "literal":
		return Expr_literal{
			Any: query[1].(interface{}),
		}
	case "true":
		return Expr_true{}
	case "false":
		return Expr_false{}
	case "get":

		varVals := []string{}
		queryArgs := query[1:]
		for i := range queryArgs {
			varVals = append(varVals, queryArgs[i].(string))
		}
		return Expr_get{
			Keys: varVals,
		}
	case "seq":

		varVals := []Expr{}
		queryArgs := query[1:]
		for i := range queryArgs {
			varVals = append(varVals, QToExpr(queryArgs[i].([]interface{})))
		}
		return Expr_seq{
			Delegates: varVals,
		}
	case "eq":

		varVals := []Expr{}
		queryArgs := query[1:]
		for i := range queryArgs {
			varVals = append(varVals, QToExpr(queryArgs[i].([]interface{})))
		}
		return Expr_eq{
			Values: varVals,
		}
	case "and":

		varVals := []Expr{}
		queryArgs := query[1:]
		for i := range queryArgs {
			varVals = append(varVals, QToExpr(queryArgs[i].([]interface{})))
		}
		return Expr_and{
			Predicates: varVals,
		}
	case "or":

		varVals := []Expr{}
		queryArgs := query[1:]
		for i := range queryArgs {
			varVals = append(varVals, QToExpr(queryArgs[i].([]interface{})))
		}
		return Expr_or{
			Predicates: varVals,
		}

	}

	panic("unrecognized expression name")
}
