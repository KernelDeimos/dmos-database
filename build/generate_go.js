const { init } = require('regjstry');

var c = init();
require('../src_js/mlang')(c);

var r = c.registry;

var files = {};

var gotyp = typeName => typeName == 'expr' ? 'Expr' : typeName;

files['sw_predicate'] = `package dmos

// THIS FILE WAS GENERATED BY generate_go.js

import (
  ${(() => {
    let imports = {};
    for ( let imp of r.getAll('expr').map(res => res.v.goimports).flat() ) {
      if ( ! imp ) continue;
      imports[imp] = true;
    }
    return Object.keys(imports).map(v => `"${v}"`).join(`\n`);
  })()}
)

type Expr interface {
  F(data interface{}) interface{}
}

${(() => {
  var results = r.getAll('expr'); // ???: scope to rooibos.dmos.mlang
  var output = '';
  for ( let result of results ) {
    let argType = result.v.argType || 'Expr';
    let resultArgs = [...(result.v.args || [])];
    let args = '', varArg = null;
    if ( result.v.variadic ) varArg = resultArgs.pop();
    for ( let arg of resultArgs ) {
      args += `${arg.name} ${gotyp(arg.type)}`;
    }
    if ( varArg ) {
      args += `${varArg.name} []${gotyp(varArg.type)}`
    }
    var name = `Expr_${result.k.split('.').slice(-1)[0]}`;
    output += `
      type ${name} struct {
        ${args}
      }

      func (pred ${name}) F(data interface{}) interface{} {
        ${result.v.gocode}
      }
    `;
  }
  return output;
})()}

func QToExpr(query []interface{}) Expr {
  fname := query[0].(string)

  switch fname {
    ${(() => {
      var results = r.getAll('expr');
      var output = '';
      for ( let result of results ) {
        let name = result.k.split('.').slice(-1)[0];
        let conv = argType => argType == 'expr'
          ? val => `QToExpr(${val}.([]interface{}))`
          : val => `${val}.(${argType})`
          ;

        output += `case "${name}":\n`;

        let resultArgs = [...(result.v.args || [])];
        let varArg = null;
        if ( result.v.variadic ) {
          varArg = resultArgs.pop();
          output += `
            varVals := []${gotyp(varArg.type)}{}
            queryArgs := query[${resultArgs.length+1}:]
            for i := range queryArgs {
              varVals = append(varVals, ${conv(varArg.type)(`queryArgs[i]`)})
            }
          `
        }
        output += `return Expr_${name}{\n`;
        for ( let i = 0 ; i < resultArgs.length ; i++ ) {
          let arg = resultArgs[i];
          output += `${arg.name}: ${conv(arg.type)(`query[${i+1}]`)},\n`;
        }
        if ( varArg ) output += `${varArg.name}: varVals,\n`
        output += `}\n`;
      }
      return output
    })()}
  }

  panic("unrecognized expression name");
}
`;

console.log(files['sw_predicate'])
